application:
  version: @project.version@
  title: BZA[edge-service]

server:
  port: ${SERVER_PORT}
  netty:
    connection-timeout: ${SERVER_CONNECTION_TIMEOUT} # how long to wait for a TCP connection to be established with the server
    idle-timeout: ${SERVER_IDLE_TIMEOUT} # how long to wait before closing a TCP connection if no data is transferred
  shutdown: graceful

spring:
  application:
    name: edge-service
  profiles:
    active: ${ACTIVE_PROFILE}
  lifecycle:
    timeout-per-shutdown-phase: ${LIFECYCLE_TIMEOUT_PER_SHUTDOWN} # defines N-second grace period for the application to terminate
  data:
    redis:
      host: ${REDIS_HOST}
      port: ${REDIS_PORT}
      timeout: ${REDIS_TIMEOUT}
      connect-timeout: ${REDIS_CONNECT_TIMEOUT}
  cloud:
    gateway:
      server:
        webflux:
          routes:
            - id: catalog-service
              uri: ${CATALOG_SERVICE_URL}
              predicates:
                - Path=/api/v1/catalog/**
              filter:
                - name: CircuitBreaker
                  args:
                    name: catalogCircuitBreaker
                    fallbackUri: forward:/catalog-fallback
            - id: order-service
              uri: ${ORDER_SERVICE_URL}
              predicates:
                - Path=/api/v1/orders/**
              filter:
                - name: CircuitBreaker
                  args:
                    name: orderCircuitBreaker
          httpclient:
            pool:
              type: elastic
              max-idle-time: ${GATEWAY_HTTPCLIENT_POOL_MAX_IDLE_TIME}
              max-life-time: ${GATEWAY_HTTPCLIENT_POOL_MAX_LIFE_TIME}
            connect-timeout: ${GATEWAY_HTTPCLIENT_CONNECT_TIMEOUT}
            response-timeout: ${GATEWAY_HTTPCLIENT_RESPONSE_TIMEOUT}
          default-filters:
            - name: Retry
              args:
                retries: ${RETRY_COUNT}
                methods: GET
                series: SERVER_ERROR
                exceptions: java.io.IOException, java.util.concurrent.TimeoutException
                backoff:
                  firstBackoff: ${RETRY_FIRST_BACKOFF}
                  maxBackoff: ${RETRY_MAX_BACKOFF}
                  factor: ${RETRY_FACTOR}
                  basedOnPreviousValue: false
            - name: RequestRateLimiter
              args:
                redis-rate-limiter:
                  replenishRate: ${REDIS_RATE_LIMITER_REPLENISH_RATE} # Number of tokens dripped in the bucket each second
                  burstCapacity: ${REDIS_RATE_LIMITER_BURST_CAPACITY} # Allows request bursts of up to X requests
                  requestedTokens: ${REDIS_RATE_LIMITER_REQUESTED_TOKENS} # how many tokens a request costs

resilience4j:
  circuitbreaker:
    configs:
      default:
        slidingWindowSize: ${CIRCUIT_BREAKER_SLIDING_WINDOW_SIZE}
        failureRateThreshold: ${CIRCUIT_BREAKER_FAILURE_RATE_THRESHOLD}
        waitDurationInOpenState: ${CIRCUIT_BREAKER_WAIT_MS_DURATION_IN_OPEN_STATE}
        permittedNumberOfCallsInHalfOpenState: ${CIRCUIT_BREAKER_PERMITTED_NUMBER_OF_CALLS_IN_HALF_OPEN_STATE}
  timelimiter:
    configs:
      default:
        timeoutDuration: ${TIME_LIMITER_TIMEOUT_DURATION} # take precedence over gateway.server.webflux.httpclient response timeout

logging:
  level:
    com.bazinga.eg.edgeservice: warn
    org.springframework.boot: warn
    org.springframework.cloud.gateway: warn
    org.springframework.web: warn
    io.github.resilience4j: warn